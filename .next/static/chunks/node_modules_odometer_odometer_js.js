/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_odometer_odometer_js"],{

/***/ "./node_modules/odometer/odometer.js":
/*!*******************************************!*\
  !*** ./node_modules/odometer/odometer.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n  var COUNT_FRAMERATE, COUNT_MS_PER_FRAME, DIGIT_FORMAT, DIGIT_HTML, DIGIT_SPEEDBOOST, DURATION, FORMAT_MARK_HTML, FORMAT_PARSER, FRAMERATE, FRAMES_PER_VALUE, MS_PER_FRAME, MutationObserver, Odometer, RIBBON_HTML, TRANSITION_END_EVENTS, TRANSITION_SUPPORT, VALUE_HTML, addClass, createFromHTML, fractionalPart, now, removeClass, requestAnimationFrame, round, transitionCheckStyles, trigger, truncate, wrapJQuery, _jQueryWrapped, _old, _ref, _ref1,\n    __slice = [].slice;\n\n  VALUE_HTML = '<span class=\"odometer-value\"></span>';\n\n  RIBBON_HTML = '<span class=\"odometer-ribbon\"><span class=\"odometer-ribbon-inner\">' + VALUE_HTML + '</span></span>';\n\n  DIGIT_HTML = '<span class=\"odometer-digit\"><span class=\"odometer-digit-spacer\">8</span><span class=\"odometer-digit-inner\">' + RIBBON_HTML + '</span></span>';\n\n  FORMAT_MARK_HTML = '<span class=\"odometer-formatting-mark\"></span>';\n\n  DIGIT_FORMAT = '(,ddd).dd';\n\n  FORMAT_PARSER = /^\\(?([^)]*)\\)?(?:(.)(d+))?$/;\n\n  FRAMERATE = 30;\n\n  DURATION = 2000;\n\n  COUNT_FRAMERATE = 20;\n\n  FRAMES_PER_VALUE = 2;\n\n  DIGIT_SPEEDBOOST = .5;\n\n  MS_PER_FRAME = 1000 / FRAMERATE;\n\n  COUNT_MS_PER_FRAME = 1000 / COUNT_FRAMERATE;\n\n  TRANSITION_END_EVENTS = 'transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd';\n\n  transitionCheckStyles = document.createElement('div').style;\n\n  TRANSITION_SUPPORT = (transitionCheckStyles.transition != null) || (transitionCheckStyles.webkitTransition != null) || (transitionCheckStyles.mozTransition != null) || (transitionCheckStyles.oTransition != null);\n\n  requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n\n  MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n\n  createFromHTML = function(html) {\n    var el;\n    el = document.createElement('div');\n    el.innerHTML = html;\n    return el.children[0];\n  };\n\n  removeClass = function(el, name) {\n    return el.className = el.className.replace(new RegExp(\"(^| )\" + (name.split(' ').join('|')) + \"( |$)\", 'gi'), ' ');\n  };\n\n  addClass = function(el, name) {\n    removeClass(el, name);\n    return el.className += \" \" + name;\n  };\n\n  trigger = function(el, name) {\n    var evt;\n    if (document.createEvent != null) {\n      evt = document.createEvent('HTMLEvents');\n      evt.initEvent(name, true, true);\n      return el.dispatchEvent(evt);\n    }\n  };\n\n  now = function() {\n    var _ref, _ref1;\n    return (_ref = (_ref1 = window.performance) != null ? typeof _ref1.now === \"function\" ? _ref1.now() : void 0 : void 0) != null ? _ref : +(new Date);\n  };\n\n  round = function(val, precision) {\n    if (precision == null) {\n      precision = 0;\n    }\n    if (!precision) {\n      return Math.round(val);\n    }\n    val *= Math.pow(10, precision);\n    val += 0.5;\n    val = Math.floor(val);\n    return val /= Math.pow(10, precision);\n  };\n\n  truncate = function(val) {\n    if (val < 0) {\n      return Math.ceil(val);\n    } else {\n      return Math.floor(val);\n    }\n  };\n\n  fractionalPart = function(val) {\n    return val - round(val);\n  };\n\n  _jQueryWrapped = false;\n\n  (wrapJQuery = function() {\n    var property, _i, _len, _ref, _results;\n    if (_jQueryWrapped) {\n      return;\n    }\n    if (window.jQuery != null) {\n      _jQueryWrapped = true;\n      _ref = ['html', 'text'];\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        property = _ref[_i];\n        _results.push((function(property) {\n          var old;\n          old = window.jQuery.fn[property];\n          return window.jQuery.fn[property] = function(val) {\n            var _ref1;\n            if ((val == null) || (((_ref1 = this[0]) != null ? _ref1.odometer : void 0) == null)) {\n              return old.apply(this, arguments);\n            }\n            return this[0].odometer.update(val);\n          };\n        })(property));\n      }\n      return _results;\n    }\n  })();\n\n  setTimeout(wrapJQuery, 0);\n\n  Odometer = (function() {\n    function Odometer(options) {\n      var e, k, property, v, _base, _i, _len, _ref, _ref1, _ref2,\n        _this = this;\n      this.options = options;\n      this.el = this.options.el;\n      if (this.el.odometer != null) {\n        return this.el.odometer;\n      }\n      this.el.odometer = this;\n      _ref = Odometer.options;\n      for (k in _ref) {\n        v = _ref[k];\n        if (this.options[k] == null) {\n          this.options[k] = v;\n        }\n      }\n      if ((_base = this.options).duration == null) {\n        _base.duration = DURATION;\n      }\n      this.MAX_VALUES = ((this.options.duration / MS_PER_FRAME) / FRAMES_PER_VALUE) | 0;\n      this.resetFormat();\n      this.value = this.cleanValue((_ref1 = this.options.value) != null ? _ref1 : '');\n      this.renderInside();\n      this.render();\n      try {\n        _ref2 = ['innerHTML', 'innerText', 'textContent'];\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          property = _ref2[_i];\n          if (this.el[property] != null) {\n            (function(property) {\n              return Object.defineProperty(_this.el, property, {\n                get: function() {\n                  var _ref3;\n                  if (property === 'innerHTML') {\n                    return _this.inside.outerHTML;\n                  } else {\n                    return (_ref3 = _this.inside.innerText) != null ? _ref3 : _this.inside.textContent;\n                  }\n                },\n                set: function(val) {\n                  return _this.update(val);\n                }\n              });\n            })(property);\n          }\n        }\n      } catch (_error) {\n        e = _error;\n        this.watchForMutations();\n      }\n      this;\n    }\n\n    Odometer.prototype.renderInside = function() {\n      this.inside = document.createElement('div');\n      this.inside.className = 'odometer-inside';\n      this.el.innerHTML = '';\n      return this.el.appendChild(this.inside);\n    };\n\n    Odometer.prototype.watchForMutations = function() {\n      var e,\n        _this = this;\n      if (MutationObserver == null) {\n        return;\n      }\n      try {\n        if (this.observer == null) {\n          this.observer = new MutationObserver(function(mutations) {\n            var newVal;\n            newVal = _this.el.innerText;\n            _this.renderInside();\n            _this.render(_this.value);\n            return _this.update(newVal);\n          });\n        }\n        this.watchMutations = true;\n        return this.startWatchingMutations();\n      } catch (_error) {\n        e = _error;\n      }\n    };\n\n    Odometer.prototype.startWatchingMutations = function() {\n      if (this.watchMutations) {\n        return this.observer.observe(this.el, {\n          childList: true\n        });\n      }\n    };\n\n    Odometer.prototype.stopWatchingMutations = function() {\n      var _ref;\n      return (_ref = this.observer) != null ? _ref.disconnect() : void 0;\n    };\n\n    Odometer.prototype.cleanValue = function(val) {\n      var _ref;\n      if (typeof val === 'string') {\n        val = val.replace((_ref = this.format.radix) != null ? _ref : '.', '<radix>');\n        val = val.replace(/[.,]/g, '');\n        val = val.replace('<radix>', '.');\n        val = parseFloat(val, 10) || 0;\n      }\n      return round(val, this.format.precision);\n    };\n\n    Odometer.prototype.bindTransitionEnd = function() {\n      var event, renderEnqueued, _i, _len, _ref, _results,\n        _this = this;\n      if (this.transitionEndBound) {\n        return;\n      }\n      this.transitionEndBound = true;\n      renderEnqueued = false;\n      _ref = TRANSITION_END_EVENTS.split(' ');\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        event = _ref[_i];\n        _results.push(this.el.addEventListener(event, function() {\n          if (renderEnqueued) {\n            return true;\n          }\n          renderEnqueued = true;\n          setTimeout(function() {\n            _this.render();\n            renderEnqueued = false;\n            return trigger(_this.el, 'odometerdone');\n          }, 0);\n          return true;\n        }, false));\n      }\n      return _results;\n    };\n\n    Odometer.prototype.resetFormat = function() {\n      var format, fractional, parsed, precision, radix, repeating, _ref, _ref1;\n      format = (_ref = this.options.format) != null ? _ref : DIGIT_FORMAT;\n      format || (format = 'd');\n      parsed = FORMAT_PARSER.exec(format);\n      if (!parsed) {\n        throw new Error(\"Odometer: Unparsable digit format\");\n      }\n      _ref1 = parsed.slice(1, 4), repeating = _ref1[0], radix = _ref1[1], fractional = _ref1[2];\n      precision = (fractional != null ? fractional.length : void 0) || 0;\n      return this.format = {\n        repeating: repeating,\n        radix: radix,\n        precision: precision\n      };\n    };\n\n    Odometer.prototype.render = function(value) {\n      var classes, cls, match, newClasses, theme, _i, _len;\n      if (value == null) {\n        value = this.value;\n      }\n      this.stopWatchingMutations();\n      this.resetFormat();\n      this.inside.innerHTML = '';\n      theme = this.options.theme;\n      classes = this.el.className.split(' ');\n      newClasses = [];\n      for (_i = 0, _len = classes.length; _i < _len; _i++) {\n        cls = classes[_i];\n        if (!cls.length) {\n          continue;\n        }\n        if (match = /^odometer-theme-(.+)$/.exec(cls)) {\n          theme = match[1];\n          continue;\n        }\n        if (/^odometer(-|$)/.test(cls)) {\n          continue;\n        }\n        newClasses.push(cls);\n      }\n      newClasses.push('odometer');\n      if (!TRANSITION_SUPPORT) {\n        newClasses.push('odometer-no-transitions');\n      }\n      if (theme) {\n        newClasses.push(\"odometer-theme-\" + theme);\n      } else {\n        newClasses.push(\"odometer-auto-theme\");\n      }\n      this.el.className = newClasses.join(' ');\n      this.ribbons = {};\n      this.formatDigits(value);\n      return this.startWatchingMutations();\n    };\n\n    Odometer.prototype.formatDigits = function(value) {\n      var digit, valueDigit, valueString, wholePart, _i, _j, _len, _len1, _ref, _ref1;\n      this.digits = [];\n      if (this.options.formatFunction) {\n        valueString = this.options.formatFunction(value);\n        _ref = valueString.split('').reverse();\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          valueDigit = _ref[_i];\n          if (valueDigit.match(/0-9/)) {\n            digit = this.renderDigit();\n            digit.querySelector('.odometer-value').innerHTML = valueDigit;\n            this.digits.push(digit);\n            this.insertDigit(digit);\n          } else {\n            this.addSpacer(valueDigit);\n          }\n        }\n      } else {\n        wholePart = !this.format.precision || !fractionalPart(value) || false;\n        _ref1 = value.toString().split('').reverse();\n        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n          digit = _ref1[_j];\n          if (digit === '.') {\n            wholePart = true;\n          }\n          this.addDigit(digit, wholePart);\n        }\n      }\n    };\n\n    Odometer.prototype.update = function(newValue) {\n      var diff,\n        _this = this;\n      newValue = this.cleanValue(newValue);\n      if (!(diff = newValue - this.value)) {\n        return;\n      }\n      removeClass(this.el, 'odometer-animating-up odometer-animating-down odometer-animating');\n      if (diff > 0) {\n        addClass(this.el, 'odometer-animating-up');\n      } else {\n        addClass(this.el, 'odometer-animating-down');\n      }\n      this.stopWatchingMutations();\n      this.animate(newValue);\n      this.startWatchingMutations();\n      setTimeout(function() {\n        _this.el.offsetHeight;\n        return addClass(_this.el, 'odometer-animating');\n      }, 0);\n      return this.value = newValue;\n    };\n\n    Odometer.prototype.renderDigit = function() {\n      return createFromHTML(DIGIT_HTML);\n    };\n\n    Odometer.prototype.insertDigit = function(digit, before) {\n      if (before != null) {\n        return this.inside.insertBefore(digit, before);\n      } else if (!this.inside.children.length) {\n        return this.inside.appendChild(digit);\n      } else {\n        return this.inside.insertBefore(digit, this.inside.children[0]);\n      }\n    };\n\n    Odometer.prototype.addSpacer = function(chr, before, extraClasses) {\n      var spacer;\n      spacer = createFromHTML(FORMAT_MARK_HTML);\n      spacer.innerHTML = chr;\n      if (extraClasses) {\n        addClass(spacer, extraClasses);\n      }\n      return this.insertDigit(spacer, before);\n    };\n\n    Odometer.prototype.addDigit = function(value, repeating) {\n      var chr, digit, resetted, _ref;\n      if (repeating == null) {\n        repeating = true;\n      }\n      if (value === '-') {\n        return this.addSpacer(value, null, 'odometer-negation-mark');\n      }\n      if (value === '.') {\n        return this.addSpacer((_ref = this.format.radix) != null ? _ref : '.', null, 'odometer-radix-mark');\n      }\n      if (repeating) {\n        resetted = false;\n        while (true) {\n          if (!this.format.repeating.length) {\n            if (resetted) {\n              throw new Error(\"Bad odometer format without digits\");\n            }\n            this.resetFormat();\n            resetted = true;\n          }\n          chr = this.format.repeating[this.format.repeating.length - 1];\n          this.format.repeating = this.format.repeating.substring(0, this.format.repeating.length - 1);\n          if (chr === 'd') {\n            break;\n          }\n          this.addSpacer(chr);\n        }\n      }\n      digit = this.renderDigit();\n      digit.querySelector('.odometer-value').innerHTML = value;\n      this.digits.push(digit);\n      return this.insertDigit(digit);\n    };\n\n    Odometer.prototype.animate = function(newValue) {\n      if (!TRANSITION_SUPPORT || this.options.animation === 'count') {\n        return this.animateCount(newValue);\n      } else {\n        return this.animateSlide(newValue);\n      }\n    };\n\n    Odometer.prototype.animateCount = function(newValue) {\n      var cur, diff, last, start, tick,\n        _this = this;\n      if (!(diff = +newValue - this.value)) {\n        return;\n      }\n      start = last = now();\n      cur = this.value;\n      return (tick = function() {\n        var delta, dist, fraction;\n        if ((now() - start) > _this.options.duration) {\n          _this.value = newValue;\n          _this.render();\n          trigger(_this.el, 'odometerdone');\n          return;\n        }\n        delta = now() - last;\n        if (delta > COUNT_MS_PER_FRAME) {\n          last = now();\n          fraction = delta / _this.options.duration;\n          dist = diff * fraction;\n          cur += dist;\n          _this.render(Math.round(cur));\n        }\n        if (requestAnimationFrame != null) {\n          return requestAnimationFrame(tick);\n        } else {\n          return setTimeout(tick, COUNT_MS_PER_FRAME);\n        }\n      })();\n    };\n\n    Odometer.prototype.getDigitCount = function() {\n      var i, max, value, values, _i, _len;\n      values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {\n        value = values[i];\n        values[i] = Math.abs(value);\n      }\n      max = Math.max.apply(Math, values);\n      return Math.ceil(Math.log(max + 1) / Math.log(10));\n    };\n\n    Odometer.prototype.getFractionalDigitCount = function() {\n      var i, parser, parts, value, values, _i, _len;\n      values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      parser = /^\\-?\\d*\\.(\\d*?)0*$/;\n      for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {\n        value = values[i];\n        values[i] = value.toString();\n        parts = parser.exec(values[i]);\n        if (parts == null) {\n          values[i] = 0;\n        } else {\n          values[i] = parts[1].length;\n        }\n      }\n      return Math.max.apply(Math, values);\n    };\n\n    Odometer.prototype.resetDigits = function() {\n      this.digits = [];\n      this.ribbons = [];\n      this.inside.innerHTML = '';\n      return this.resetFormat();\n    };\n\n    Odometer.prototype.animateSlide = function(newValue) {\n      var boosted, cur, diff, digitCount, digits, dist, end, fractionalCount, frame, frames, i, incr, j, mark, numEl, oldValue, start, _base, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _results;\n      oldValue = this.value;\n      fractionalCount = this.getFractionalDigitCount(oldValue, newValue);\n      if (fractionalCount) {\n        newValue = newValue * Math.pow(10, fractionalCount);\n        oldValue = oldValue * Math.pow(10, fractionalCount);\n      }\n      if (!(diff = newValue - oldValue)) {\n        return;\n      }\n      this.bindTransitionEnd();\n      digitCount = this.getDigitCount(oldValue, newValue);\n      digits = [];\n      boosted = 0;\n      for (i = _i = 0; 0 <= digitCount ? _i < digitCount : _i > digitCount; i = 0 <= digitCount ? ++_i : --_i) {\n        start = truncate(oldValue / Math.pow(10, digitCount - i - 1));\n        end = truncate(newValue / Math.pow(10, digitCount - i - 1));\n        dist = end - start;\n        if (Math.abs(dist) > this.MAX_VALUES) {\n          frames = [];\n          incr = dist / (this.MAX_VALUES + this.MAX_VALUES * boosted * DIGIT_SPEEDBOOST);\n          cur = start;\n          while ((dist > 0 && cur < end) || (dist < 0 && cur > end)) {\n            frames.push(Math.round(cur));\n            cur += incr;\n          }\n          if (frames[frames.length - 1] !== end) {\n            frames.push(end);\n          }\n          boosted++;\n        } else {\n          frames = (function() {\n            _results = [];\n            for (var _j = start; start <= end ? _j <= end : _j >= end; start <= end ? _j++ : _j--){ _results.push(_j); }\n            return _results;\n          }).apply(this);\n        }\n        for (i = _k = 0, _len = frames.length; _k < _len; i = ++_k) {\n          frame = frames[i];\n          frames[i] = Math.abs(frame % 10);\n        }\n        digits.push(frames);\n      }\n      this.resetDigits();\n      _ref = digits.reverse();\n      for (i = _l = 0, _len1 = _ref.length; _l < _len1; i = ++_l) {\n        frames = _ref[i];\n        if (!this.digits[i]) {\n          this.addDigit(' ', i >= fractionalCount);\n        }\n        if ((_base = this.ribbons)[i] == null) {\n          _base[i] = this.digits[i].querySelector('.odometer-ribbon-inner');\n        }\n        this.ribbons[i].innerHTML = '';\n        if (diff < 0) {\n          frames = frames.reverse();\n        }\n        for (j = _m = 0, _len2 = frames.length; _m < _len2; j = ++_m) {\n          frame = frames[j];\n          numEl = document.createElement('div');\n          numEl.className = 'odometer-value';\n          numEl.innerHTML = frame;\n          this.ribbons[i].appendChild(numEl);\n          if (j === frames.length - 1) {\n            addClass(numEl, 'odometer-last-value');\n          }\n          if (j === 0) {\n            addClass(numEl, 'odometer-first-value');\n          }\n        }\n      }\n      if (start < 0) {\n        this.addDigit('-');\n      }\n      mark = this.inside.querySelector('.odometer-radix-mark');\n      if (mark != null) {\n        mark.parent.removeChild(mark);\n      }\n      if (fractionalCount) {\n        return this.addSpacer(this.format.radix, this.digits[fractionalCount - 1], 'odometer-radix-mark');\n      }\n    };\n\n    return Odometer;\n\n  })();\n\n  Odometer.options = (_ref = window.odometerOptions) != null ? _ref : {};\n\n  setTimeout(function() {\n    var k, v, _base, _ref1, _results;\n    if (window.odometerOptions) {\n      _ref1 = window.odometerOptions;\n      _results = [];\n      for (k in _ref1) {\n        v = _ref1[k];\n        _results.push((_base = Odometer.options)[k] != null ? (_base = Odometer.options)[k] : _base[k] = v);\n      }\n      return _results;\n    }\n  }, 0);\n\n  Odometer.init = function() {\n    var el, elements, _i, _len, _ref1, _results;\n    if (document.querySelectorAll == null) {\n      return;\n    }\n    elements = document.querySelectorAll(Odometer.options.selector || '.odometer');\n    _results = [];\n    for (_i = 0, _len = elements.length; _i < _len; _i++) {\n      el = elements[_i];\n      _results.push(el.odometer = new Odometer({\n        el: el,\n        value: (_ref1 = el.innerText) != null ? _ref1 : el.textContent\n      }));\n    }\n    return _results;\n  };\n\n  if ((((_ref1 = document.documentElement) != null ? _ref1.doScroll : void 0) != null) && (document.createEventObject != null)) {\n    _old = document.onreadystatechange;\n    document.onreadystatechange = function() {\n      if (document.readyState === 'complete' && Odometer.options.auto !== false) {\n        Odometer.init();\n      }\n      return _old != null ? _old.apply(this, arguments) : void 0;\n    };\n  } else {\n    document.addEventListener('DOMContentLoaded', function() {\n      if (Odometer.options.auto !== false) {\n        return Odometer.init();\n      }\n    }, false);\n  }\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return Odometer;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2RvbWV0ZXIvb2RvbWV0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBcUQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxpQ0FBaUMsc0NBQXNDLDZCQUE2QjtBQUNwRztBQUNBLFdBQVc7QUFDWDtBQUNBLCtDQUErQyxXQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsTUFBTSxJQUEwQztBQUNoRCxJQUFJLGlDQUFPLEVBQUUsbUNBQUU7QUFDZjtBQUNBLEtBQUs7QUFBQSxrR0FBQztBQUNOLElBQUksS0FBSyxFQUlOOztBQUVILENBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc2lkZGhcXERvd25sb2Fkc1xcYnJpZ2h0TGlnaHRfRnJvbnRlbmRcXGJyaWdodExpZ2h0X0Zyb250ZW5kXzAyLW1haW5cXG5vZGVfbW9kdWxlc1xcb2RvbWV0ZXJcXG9kb21ldGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpIHtcbiAgdmFyIENPVU5UX0ZSQU1FUkFURSwgQ09VTlRfTVNfUEVSX0ZSQU1FLCBESUdJVF9GT1JNQVQsIERJR0lUX0hUTUwsIERJR0lUX1NQRUVEQk9PU1QsIERVUkFUSU9OLCBGT1JNQVRfTUFSS19IVE1MLCBGT1JNQVRfUEFSU0VSLCBGUkFNRVJBVEUsIEZSQU1FU19QRVJfVkFMVUUsIE1TX1BFUl9GUkFNRSwgTXV0YXRpb25PYnNlcnZlciwgT2RvbWV0ZXIsIFJJQkJPTl9IVE1MLCBUUkFOU0lUSU9OX0VORF9FVkVOVFMsIFRSQU5TSVRJT05fU1VQUE9SVCwgVkFMVUVfSFRNTCwgYWRkQ2xhc3MsIGNyZWF0ZUZyb21IVE1MLCBmcmFjdGlvbmFsUGFydCwgbm93LCByZW1vdmVDbGFzcywgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCByb3VuZCwgdHJhbnNpdGlvbkNoZWNrU3R5bGVzLCB0cmlnZ2VyLCB0cnVuY2F0ZSwgd3JhcEpRdWVyeSwgX2pRdWVyeVdyYXBwZWQsIF9vbGQsIF9yZWYsIF9yZWYxLFxuICAgIF9fc2xpY2UgPSBbXS5zbGljZTtcblxuICBWQUxVRV9IVE1MID0gJzxzcGFuIGNsYXNzPVwib2RvbWV0ZXItdmFsdWVcIj48L3NwYW4+JztcblxuICBSSUJCT05fSFRNTCA9ICc8c3BhbiBjbGFzcz1cIm9kb21ldGVyLXJpYmJvblwiPjxzcGFuIGNsYXNzPVwib2RvbWV0ZXItcmliYm9uLWlubmVyXCI+JyArIFZBTFVFX0hUTUwgKyAnPC9zcGFuPjwvc3Bhbj4nO1xuXG4gIERJR0lUX0hUTUwgPSAnPHNwYW4gY2xhc3M9XCJvZG9tZXRlci1kaWdpdFwiPjxzcGFuIGNsYXNzPVwib2RvbWV0ZXItZGlnaXQtc3BhY2VyXCI+ODwvc3Bhbj48c3BhbiBjbGFzcz1cIm9kb21ldGVyLWRpZ2l0LWlubmVyXCI+JyArIFJJQkJPTl9IVE1MICsgJzwvc3Bhbj48L3NwYW4+JztcblxuICBGT1JNQVRfTUFSS19IVE1MID0gJzxzcGFuIGNsYXNzPVwib2RvbWV0ZXItZm9ybWF0dGluZy1tYXJrXCI+PC9zcGFuPic7XG5cbiAgRElHSVRfRk9STUFUID0gJygsZGRkKS5kZCc7XG5cbiAgRk9STUFUX1BBUlNFUiA9IC9eXFwoPyhbXildKilcXCk/KD86KC4pKGQrKSk/JC87XG5cbiAgRlJBTUVSQVRFID0gMzA7XG5cbiAgRFVSQVRJT04gPSAyMDAwO1xuXG4gIENPVU5UX0ZSQU1FUkFURSA9IDIwO1xuXG4gIEZSQU1FU19QRVJfVkFMVUUgPSAyO1xuXG4gIERJR0lUX1NQRUVEQk9PU1QgPSAuNTtcblxuICBNU19QRVJfRlJBTUUgPSAxMDAwIC8gRlJBTUVSQVRFO1xuXG4gIENPVU5UX01TX1BFUl9GUkFNRSA9IDEwMDAgLyBDT1VOVF9GUkFNRVJBVEU7XG5cbiAgVFJBTlNJVElPTl9FTkRfRVZFTlRTID0gJ3RyYW5zaXRpb25lbmQgd2Via2l0VHJhbnNpdGlvbkVuZCBvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCBNU1RyYW5zaXRpb25FbmQnO1xuXG4gIHRyYW5zaXRpb25DaGVja1N0eWxlcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuXG4gIFRSQU5TSVRJT05fU1VQUE9SVCA9ICh0cmFuc2l0aW9uQ2hlY2tTdHlsZXMudHJhbnNpdGlvbiAhPSBudWxsKSB8fCAodHJhbnNpdGlvbkNoZWNrU3R5bGVzLndlYmtpdFRyYW5zaXRpb24gIT0gbnVsbCkgfHwgKHRyYW5zaXRpb25DaGVja1N0eWxlcy5tb3pUcmFuc2l0aW9uICE9IG51bGwpIHx8ICh0cmFuc2l0aW9uQ2hlY2tTdHlsZXMub1RyYW5zaXRpb24gIT0gbnVsbCk7XG5cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4gIE11dGF0aW9uT2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuTW96TXV0YXRpb25PYnNlcnZlcjtcblxuICBjcmVhdGVGcm9tSFRNTCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICB2YXIgZWw7XG4gICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBlbC5jaGlsZHJlblswXTtcbiAgfTtcblxuICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgcmV0dXJuIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoXnwgKVwiICsgKG5hbWUuc3BsaXQoJyAnKS5qb2luKCd8JykpICsgXCIoIHwkKVwiLCAnZ2knKSwgJyAnKTtcbiAgfTtcblxuICBhZGRDbGFzcyA9IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG4gICAgcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpO1xuICAgIHJldHVybiBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBuYW1lO1xuICB9O1xuXG4gIHRyaWdnZXIgPSBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgIHZhciBldnQ7XG4gICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50ICE9IG51bGwpIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgICBldnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuICAgICAgcmV0dXJuIGVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9XG4gIH07XG5cbiAgbm93ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9yZWYsIF9yZWYxO1xuICAgIHJldHVybiAoX3JlZiA9IChfcmVmMSA9IHdpbmRvdy5wZXJmb3JtYW5jZSkgIT0gbnVsbCA/IHR5cGVvZiBfcmVmMS5ub3cgPT09IFwiZnVuY3Rpb25cIiA/IF9yZWYxLm5vdygpIDogdm9pZCAwIDogdm9pZCAwKSAhPSBudWxsID8gX3JlZiA6ICsobmV3IERhdGUpO1xuICB9O1xuXG4gIHJvdW5kID0gZnVuY3Rpb24odmFsLCBwcmVjaXNpb24pIHtcbiAgICBpZiAocHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgIHByZWNpc2lvbiA9IDA7XG4gICAgfVxuICAgIGlmICghcHJlY2lzaW9uKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwpO1xuICAgIH1cbiAgICB2YWwgKj0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgdmFsICs9IDAuNTtcbiAgICB2YWwgPSBNYXRoLmZsb29yKHZhbCk7XG4gICAgcmV0dXJuIHZhbCAvPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgfTtcblxuICB0cnVuY2F0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbCk7XG4gICAgfVxuICB9O1xuXG4gIGZyYWN0aW9uYWxQYXJ0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIHZhbCAtIHJvdW5kKHZhbCk7XG4gIH07XG5cbiAgX2pRdWVyeVdyYXBwZWQgPSBmYWxzZTtcblxuICAod3JhcEpRdWVyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9wZXJ0eSwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgIGlmIChfalF1ZXJ5V3JhcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2luZG93LmpRdWVyeSAhPSBudWxsKSB7XG4gICAgICBfalF1ZXJ5V3JhcHBlZCA9IHRydWU7XG4gICAgICBfcmVmID0gWydodG1sJywgJ3RleHQnXTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCgoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgb2xkO1xuICAgICAgICAgIG9sZCA9IHdpbmRvdy5qUXVlcnkuZm5bcHJvcGVydHldO1xuICAgICAgICAgIHJldHVybiB3aW5kb3cualF1ZXJ5LmZuW3Byb3BlcnR5XSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgdmFyIF9yZWYxO1xuICAgICAgICAgICAgaWYgKCh2YWwgPT0gbnVsbCkgfHwgKCgoX3JlZjEgPSB0aGlzWzBdKSAhPSBudWxsID8gX3JlZjEub2RvbWV0ZXIgOiB2b2lkIDApID09IG51bGwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdLm9kb21ldGVyLnVwZGF0ZSh2YWwpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHByb3BlcnR5KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfVxuICB9KSgpO1xuXG4gIHNldFRpbWVvdXQod3JhcEpRdWVyeSwgMCk7XG5cbiAgT2RvbWV0ZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gT2RvbWV0ZXIob3B0aW9ucykge1xuICAgICAgdmFyIGUsIGssIHByb3BlcnR5LCB2LCBfYmFzZSwgX2ksIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVmMixcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuZWwgPSB0aGlzLm9wdGlvbnMuZWw7XG4gICAgICBpZiAodGhpcy5lbC5vZG9tZXRlciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9kb21ldGVyO1xuICAgICAgfVxuICAgICAgdGhpcy5lbC5vZG9tZXRlciA9IHRoaXM7XG4gICAgICBfcmVmID0gT2RvbWV0ZXIub3B0aW9ucztcbiAgICAgIGZvciAoayBpbiBfcmVmKSB7XG4gICAgICAgIHYgPSBfcmVmW2tdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zW2tdID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnNba10gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKF9iYXNlID0gdGhpcy5vcHRpb25zKS5kdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIF9iYXNlLmR1cmF0aW9uID0gRFVSQVRJT047XG4gICAgICB9XG4gICAgICB0aGlzLk1BWF9WQUxVRVMgPSAoKHRoaXMub3B0aW9ucy5kdXJhdGlvbiAvIE1TX1BFUl9GUkFNRSkgLyBGUkFNRVNfUEVSX1ZBTFVFKSB8IDA7XG4gICAgICB0aGlzLnJlc2V0Rm9ybWF0KCk7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5jbGVhblZhbHVlKChfcmVmMSA9IHRoaXMub3B0aW9ucy52YWx1ZSkgIT0gbnVsbCA/IF9yZWYxIDogJycpO1xuICAgICAgdGhpcy5yZW5kZXJJbnNpZGUoKTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB0cnkge1xuICAgICAgICBfcmVmMiA9IFsnaW5uZXJIVE1MJywgJ2lubmVyVGV4dCcsICd0ZXh0Q29udGVudCddO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBfcmVmMltfaV07XG4gICAgICAgICAgaWYgKHRoaXMuZWxbcHJvcGVydHldICE9IG51bGwpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLmVsLCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZjM7XG4gICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pbnNpZGUub3V0ZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfcmVmMyA9IF90aGlzLmluc2lkZS5pbm5lclRleHQpICE9IG51bGwgPyBfcmVmMyA6IF90aGlzLmluc2lkZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgICB0aGlzLndhdGNoRm9yTXV0YXRpb25zKCk7XG4gICAgICB9XG4gICAgICB0aGlzO1xuICAgIH1cblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5yZW5kZXJJbnNpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5zaWRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmluc2lkZS5jbGFzc05hbWUgPSAnb2RvbWV0ZXItaW5zaWRlJztcbiAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICByZXR1cm4gdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLmluc2lkZSk7XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS53YXRjaEZvck11dGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChNdXRhdGlvbk9ic2VydmVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbihtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBuZXdWYWw7XG4gICAgICAgICAgICBuZXdWYWwgPSBfdGhpcy5lbC5pbm5lclRleHQ7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJJbnNpZGUoKTtcbiAgICAgICAgICAgIF90aGlzLnJlbmRlcihfdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlKG5ld1ZhbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXRjaE11dGF0aW9ucyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0V2F0Y2hpbmdNdXRhdGlvbnMoKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlID0gX2Vycm9yO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBPZG9tZXRlci5wcm90b3R5cGUuc3RhcnRXYXRjaGluZ011dGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMud2F0Y2hNdXRhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBPZG9tZXRlci5wcm90b3R5cGUuc3RvcFdhdGNoaW5nTXV0YXRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIHJldHVybiAoX3JlZiA9IHRoaXMub2JzZXJ2ZXIpICE9IG51bGwgPyBfcmVmLmRpc2Nvbm5lY3QoKSA6IHZvaWQgMDtcbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLmNsZWFuVmFsdWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKChfcmVmID0gdGhpcy5mb3JtYXQucmFkaXgpICE9IG51bGwgPyBfcmVmIDogJy4nLCAnPHJhZGl4PicpO1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvWy4sXS9nLCAnJyk7XG4gICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKCc8cmFkaXg+JywgJy4nKTtcbiAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh2YWwsIDEwKSB8fCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdW5kKHZhbCwgdGhpcy5mb3JtYXQucHJlY2lzaW9uKTtcbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLmJpbmRUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXZlbnQsIHJlbmRlckVucXVldWVkLCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25FbmRCb3VuZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zaXRpb25FbmRCb3VuZCA9IHRydWU7XG4gICAgICByZW5kZXJFbnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgX3JlZiA9IFRSQU5TSVRJT05fRU5EX0VWRU5UUy5zcGxpdCgnICcpO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBldmVudCA9IF9yZWZbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHJlbmRlckVucXVldWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVuZGVyRW5xdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIHJlbmRlckVucXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJpZ2dlcihfdGhpcy5lbCwgJ29kb21ldGVyZG9uZScpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LCBmYWxzZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBPZG9tZXRlci5wcm90b3R5cGUucmVzZXRGb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmb3JtYXQsIGZyYWN0aW9uYWwsIHBhcnNlZCwgcHJlY2lzaW9uLCByYWRpeCwgcmVwZWF0aW5nLCBfcmVmLCBfcmVmMTtcbiAgICAgIGZvcm1hdCA9IChfcmVmID0gdGhpcy5vcHRpb25zLmZvcm1hdCkgIT0gbnVsbCA/IF9yZWYgOiBESUdJVF9GT1JNQVQ7XG4gICAgICBmb3JtYXQgfHwgKGZvcm1hdCA9ICdkJyk7XG4gICAgICBwYXJzZWQgPSBGT1JNQVRfUEFSU0VSLmV4ZWMoZm9ybWF0KTtcbiAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9kb21ldGVyOiBVbnBhcnNhYmxlIGRpZ2l0IGZvcm1hdFwiKTtcbiAgICAgIH1cbiAgICAgIF9yZWYxID0gcGFyc2VkLnNsaWNlKDEsIDQpLCByZXBlYXRpbmcgPSBfcmVmMVswXSwgcmFkaXggPSBfcmVmMVsxXSwgZnJhY3Rpb25hbCA9IF9yZWYxWzJdO1xuICAgICAgcHJlY2lzaW9uID0gKGZyYWN0aW9uYWwgIT0gbnVsbCA/IGZyYWN0aW9uYWwubGVuZ3RoIDogdm9pZCAwKSB8fCAwO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0ID0ge1xuICAgICAgICByZXBlYXRpbmc6IHJlcGVhdGluZyxcbiAgICAgICAgcmFkaXg6IHJhZGl4LFxuICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvblxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2xhc3NlcywgY2xzLCBtYXRjaCwgbmV3Q2xhc3NlcywgdGhlbWUsIF9pLCBfbGVuO1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgfVxuICAgICAgdGhpcy5zdG9wV2F0Y2hpbmdNdXRhdGlvbnMoKTtcbiAgICAgIHRoaXMucmVzZXRGb3JtYXQoKTtcbiAgICAgIHRoaXMuaW5zaWRlLmlubmVySFRNTCA9ICcnO1xuICAgICAgdGhlbWUgPSB0aGlzLm9wdGlvbnMudGhlbWU7XG4gICAgICBjbGFzc2VzID0gdGhpcy5lbC5jbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICAgIG5ld0NsYXNzZXMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gY2xhc3Nlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBjbHMgPSBjbGFzc2VzW19pXTtcbiAgICAgICAgaWYgKCFjbHMubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gL15vZG9tZXRlci10aGVtZS0oLispJC8uZXhlYyhjbHMpKSB7XG4gICAgICAgICAgdGhlbWUgPSBtYXRjaFsxXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL15vZG9tZXRlcigtfCQpLy50ZXN0KGNscykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXdDbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgIH1cbiAgICAgIG5ld0NsYXNzZXMucHVzaCgnb2RvbWV0ZXInKTtcbiAgICAgIGlmICghVFJBTlNJVElPTl9TVVBQT1JUKSB7XG4gICAgICAgIG5ld0NsYXNzZXMucHVzaCgnb2RvbWV0ZXItbm8tdHJhbnNpdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGVtZSkge1xuICAgICAgICBuZXdDbGFzc2VzLnB1c2goXCJvZG9tZXRlci10aGVtZS1cIiArIHRoZW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0NsYXNzZXMucHVzaChcIm9kb21ldGVyLWF1dG8tdGhlbWVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmVsLmNsYXNzTmFtZSA9IG5ld0NsYXNzZXMuam9pbignICcpO1xuICAgICAgdGhpcy5yaWJib25zID0ge307XG4gICAgICB0aGlzLmZvcm1hdERpZ2l0cyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydFdhdGNoaW5nTXV0YXRpb25zKCk7XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5mb3JtYXREaWdpdHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGRpZ2l0LCB2YWx1ZURpZ2l0LCB2YWx1ZVN0cmluZywgd2hvbGVQYXJ0LCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmLCBfcmVmMTtcbiAgICAgIHRoaXMuZGlnaXRzID0gW107XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvcm1hdEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhbHVlU3RyaW5nID0gdGhpcy5vcHRpb25zLmZvcm1hdEZ1bmN0aW9uKHZhbHVlKTtcbiAgICAgICAgX3JlZiA9IHZhbHVlU3RyaW5nLnNwbGl0KCcnKS5yZXZlcnNlKCk7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHZhbHVlRGlnaXQgPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAodmFsdWVEaWdpdC5tYXRjaCgvMC05LykpIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gdGhpcy5yZW5kZXJEaWdpdCgpO1xuICAgICAgICAgICAgZGlnaXQucXVlcnlTZWxlY3RvcignLm9kb21ldGVyLXZhbHVlJykuaW5uZXJIVE1MID0gdmFsdWVEaWdpdDtcbiAgICAgICAgICAgIHRoaXMuZGlnaXRzLnB1c2goZGlnaXQpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnREaWdpdChkaWdpdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU3BhY2VyKHZhbHVlRGlnaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hvbGVQYXJ0ID0gIXRoaXMuZm9ybWF0LnByZWNpc2lvbiB8fCAhZnJhY3Rpb25hbFBhcnQodmFsdWUpIHx8IGZhbHNlO1xuICAgICAgICBfcmVmMSA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJycpLnJldmVyc2UoKTtcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgZGlnaXQgPSBfcmVmMVtfal07XG4gICAgICAgICAgaWYgKGRpZ2l0ID09PSAnLicpIHtcbiAgICAgICAgICAgIHdob2xlUGFydCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWRkRGlnaXQoZGlnaXQsIHdob2xlUGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICB2YXIgZGlmZixcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgbmV3VmFsdWUgPSB0aGlzLmNsZWFuVmFsdWUobmV3VmFsdWUpO1xuICAgICAgaWYgKCEoZGlmZiA9IG5ld1ZhbHVlIC0gdGhpcy52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgJ29kb21ldGVyLWFuaW1hdGluZy11cCBvZG9tZXRlci1hbmltYXRpbmctZG93biBvZG9tZXRlci1hbmltYXRpbmcnKTtcbiAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLmVsLCAnb2RvbWV0ZXItYW5pbWF0aW5nLXVwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLmVsLCAnb2RvbWV0ZXItYW5pbWF0aW5nLWRvd24nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RvcFdhdGNoaW5nTXV0YXRpb25zKCk7XG4gICAgICB0aGlzLmFuaW1hdGUobmV3VmFsdWUpO1xuICAgICAgdGhpcy5zdGFydFdhdGNoaW5nTXV0YXRpb25zKCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5lbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHJldHVybiBhZGRDbGFzcyhfdGhpcy5lbCwgJ29kb21ldGVyLWFuaW1hdGluZycpO1xuICAgICAgfSwgMCk7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH07XG5cbiAgICBPZG9tZXRlci5wcm90b3R5cGUucmVuZGVyRGlnaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGcm9tSFRNTChESUdJVF9IVE1MKTtcbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLmluc2VydERpZ2l0ID0gZnVuY3Rpb24oZGlnaXQsIGJlZm9yZSkge1xuICAgICAgaWYgKGJlZm9yZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2lkZS5pbnNlcnRCZWZvcmUoZGlnaXQsIGJlZm9yZSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmluc2lkZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zaWRlLmFwcGVuZENoaWxkKGRpZ2l0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2lkZS5pbnNlcnRCZWZvcmUoZGlnaXQsIHRoaXMuaW5zaWRlLmNoaWxkcmVuWzBdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLmFkZFNwYWNlciA9IGZ1bmN0aW9uKGNociwgYmVmb3JlLCBleHRyYUNsYXNzZXMpIHtcbiAgICAgIHZhciBzcGFjZXI7XG4gICAgICBzcGFjZXIgPSBjcmVhdGVGcm9tSFRNTChGT1JNQVRfTUFSS19IVE1MKTtcbiAgICAgIHNwYWNlci5pbm5lckhUTUwgPSBjaHI7XG4gICAgICBpZiAoZXh0cmFDbGFzc2VzKSB7XG4gICAgICAgIGFkZENsYXNzKHNwYWNlciwgZXh0cmFDbGFzc2VzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmluc2VydERpZ2l0KHNwYWNlciwgYmVmb3JlKTtcbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLmFkZERpZ2l0ID0gZnVuY3Rpb24odmFsdWUsIHJlcGVhdGluZykge1xuICAgICAgdmFyIGNociwgZGlnaXQsIHJlc2V0dGVkLCBfcmVmO1xuICAgICAgaWYgKHJlcGVhdGluZyA9PSBudWxsKSB7XG4gICAgICAgIHJlcGVhdGluZyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09ICctJykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTcGFjZXIodmFsdWUsIG51bGwsICdvZG9tZXRlci1uZWdhdGlvbi1tYXJrJyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09ICcuJykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTcGFjZXIoKF9yZWYgPSB0aGlzLmZvcm1hdC5yYWRpeCkgIT0gbnVsbCA/IF9yZWYgOiAnLicsIG51bGwsICdvZG9tZXRlci1yYWRpeC1tYXJrJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVwZWF0aW5nKSB7XG4gICAgICAgIHJlc2V0dGVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmZvcm1hdC5yZXBlYXRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAocmVzZXR0ZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIG9kb21ldGVyIGZvcm1hdCB3aXRob3V0IGRpZ2l0c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXRGb3JtYXQoKTtcbiAgICAgICAgICAgIHJlc2V0dGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hyID0gdGhpcy5mb3JtYXQucmVwZWF0aW5nW3RoaXMuZm9ybWF0LnJlcGVhdGluZy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB0aGlzLmZvcm1hdC5yZXBlYXRpbmcgPSB0aGlzLmZvcm1hdC5yZXBlYXRpbmcuc3Vic3RyaW5nKDAsIHRoaXMuZm9ybWF0LnJlcGVhdGluZy5sZW5ndGggLSAxKTtcbiAgICAgICAgICBpZiAoY2hyID09PSAnZCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkZFNwYWNlcihjaHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkaWdpdCA9IHRoaXMucmVuZGVyRGlnaXQoKTtcbiAgICAgIGRpZ2l0LnF1ZXJ5U2VsZWN0b3IoJy5vZG9tZXRlci12YWx1ZScpLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgdGhpcy5kaWdpdHMucHVzaChkaWdpdCk7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREaWdpdChkaWdpdCk7XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgIGlmICghVFJBTlNJVElPTl9TVVBQT1JUIHx8IHRoaXMub3B0aW9ucy5hbmltYXRpb24gPT09ICdjb3VudCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZUNvdW50KG5ld1ZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGVTbGlkZShuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5hbmltYXRlQ291bnQgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgdmFyIGN1ciwgZGlmZiwgbGFzdCwgc3RhcnQsIHRpY2ssXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmICghKGRpZmYgPSArbmV3VmFsdWUgLSB0aGlzLnZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdGFydCA9IGxhc3QgPSBub3coKTtcbiAgICAgIGN1ciA9IHRoaXMudmFsdWU7XG4gICAgICByZXR1cm4gKHRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlbHRhLCBkaXN0LCBmcmFjdGlvbjtcbiAgICAgICAgaWYgKChub3coKSAtIHN0YXJ0KSA+IF90aGlzLm9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgICAgICBfdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIF90aGlzLnJlbmRlcigpO1xuICAgICAgICAgIHRyaWdnZXIoX3RoaXMuZWwsICdvZG9tZXRlcmRvbmUnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsdGEgPSBub3coKSAtIGxhc3Q7XG4gICAgICAgIGlmIChkZWx0YSA+IENPVU5UX01TX1BFUl9GUkFNRSkge1xuICAgICAgICAgIGxhc3QgPSBub3coKTtcbiAgICAgICAgICBmcmFjdGlvbiA9IGRlbHRhIC8gX3RoaXMub3B0aW9ucy5kdXJhdGlvbjtcbiAgICAgICAgICBkaXN0ID0gZGlmZiAqIGZyYWN0aW9uO1xuICAgICAgICAgIGN1ciArPSBkaXN0O1xuICAgICAgICAgIF90aGlzLnJlbmRlcihNYXRoLnJvdW5kKGN1cikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQodGljaywgQ09VTlRfTVNfUEVSX0ZSQU1FKTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLmdldERpZ2l0Q291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBtYXgsIHZhbHVlLCB2YWx1ZXMsIF9pLCBfbGVuO1xuICAgICAgdmFsdWVzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgIGZvciAoaSA9IF9pID0gMCwgX2xlbiA9IHZhbHVlcy5sZW5ndGg7IF9pIDwgX2xlbjsgaSA9ICsrX2kpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIHZhbHVlc1tpXSA9IE1hdGguYWJzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIG1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKE1hdGgubG9nKG1heCArIDEpIC8gTWF0aC5sb2coMTApKTtcbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLmdldEZyYWN0aW9uYWxEaWdpdENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgcGFyc2VyLCBwYXJ0cywgdmFsdWUsIHZhbHVlcywgX2ksIF9sZW47XG4gICAgICB2YWx1ZXMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgICAgcGFyc2VyID0gL15cXC0/XFxkKlxcLihcXGQqPykwKiQvO1xuICAgICAgZm9yIChpID0gX2kgPSAwLCBfbGVuID0gdmFsdWVzLmxlbmd0aDsgX2kgPCBfbGVuOyBpID0gKytfaSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgdmFsdWVzW2ldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgcGFydHMgPSBwYXJzZXIuZXhlYyh2YWx1ZXNbaV0pO1xuICAgICAgICBpZiAocGFydHMgPT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlc1tpXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVzW2ldID0gcGFydHNbMV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICB9O1xuXG4gICAgT2RvbWV0ZXIucHJvdG90eXBlLnJlc2V0RGlnaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRpZ2l0cyA9IFtdO1xuICAgICAgdGhpcy5yaWJib25zID0gW107XG4gICAgICB0aGlzLmluc2lkZS5pbm5lckhUTUwgPSAnJztcbiAgICAgIHJldHVybiB0aGlzLnJlc2V0Rm9ybWF0KCk7XG4gICAgfTtcblxuICAgIE9kb21ldGVyLnByb3RvdHlwZS5hbmltYXRlU2xpZGUgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgdmFyIGJvb3N0ZWQsIGN1ciwgZGlmZiwgZGlnaXRDb3VudCwgZGlnaXRzLCBkaXN0LCBlbmQsIGZyYWN0aW9uYWxDb3VudCwgZnJhbWUsIGZyYW1lcywgaSwgaW5jciwgaiwgbWFyaywgbnVtRWwsIG9sZFZhbHVlLCBzdGFydCwgX2Jhc2UsIF9pLCBfaiwgX2ssIF9sLCBfbGVuLCBfbGVuMSwgX2xlbjIsIF9tLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIGZyYWN0aW9uYWxDb3VudCA9IHRoaXMuZ2V0RnJhY3Rpb25hbERpZ2l0Q291bnQob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgIGlmIChmcmFjdGlvbmFsQ291bnQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZSAqIE1hdGgucG93KDEwLCBmcmFjdGlvbmFsQ291bnQpO1xuICAgICAgICBvbGRWYWx1ZSA9IG9sZFZhbHVlICogTWF0aC5wb3coMTAsIGZyYWN0aW9uYWxDb3VudCk7XG4gICAgICB9XG4gICAgICBpZiAoIShkaWZmID0gbmV3VmFsdWUgLSBvbGRWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5iaW5kVHJhbnNpdGlvbkVuZCgpO1xuICAgICAgZGlnaXRDb3VudCA9IHRoaXMuZ2V0RGlnaXRDb3VudChvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgZGlnaXRzID0gW107XG4gICAgICBib29zdGVkID0gMDtcbiAgICAgIGZvciAoaSA9IF9pID0gMDsgMCA8PSBkaWdpdENvdW50ID8gX2kgPCBkaWdpdENvdW50IDogX2kgPiBkaWdpdENvdW50OyBpID0gMCA8PSBkaWdpdENvdW50ID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgc3RhcnQgPSB0cnVuY2F0ZShvbGRWYWx1ZSAvIE1hdGgucG93KDEwLCBkaWdpdENvdW50IC0gaSAtIDEpKTtcbiAgICAgICAgZW5kID0gdHJ1bmNhdGUobmV3VmFsdWUgLyBNYXRoLnBvdygxMCwgZGlnaXRDb3VudCAtIGkgLSAxKSk7XG4gICAgICAgIGRpc3QgPSBlbmQgLSBzdGFydDtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRpc3QpID4gdGhpcy5NQVhfVkFMVUVTKSB7XG4gICAgICAgICAgZnJhbWVzID0gW107XG4gICAgICAgICAgaW5jciA9IGRpc3QgLyAodGhpcy5NQVhfVkFMVUVTICsgdGhpcy5NQVhfVkFMVUVTICogYm9vc3RlZCAqIERJR0lUX1NQRUVEQk9PU1QpO1xuICAgICAgICAgIGN1ciA9IHN0YXJ0O1xuICAgICAgICAgIHdoaWxlICgoZGlzdCA+IDAgJiYgY3VyIDwgZW5kKSB8fCAoZGlzdCA8IDAgJiYgY3VyID4gZW5kKSkge1xuICAgICAgICAgICAgZnJhbWVzLnB1c2goTWF0aC5yb3VuZChjdXIpKTtcbiAgICAgICAgICAgIGN1ciArPSBpbmNyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXSAhPT0gZW5kKSB7XG4gICAgICAgICAgICBmcmFtZXMucHVzaChlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib29zdGVkKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhbWVzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gc3RhcnQ7IHN0YXJ0IDw9IGVuZCA/IF9qIDw9IGVuZCA6IF9qID49IGVuZDsgc3RhcnQgPD0gZW5kID8gX2orKyA6IF9qLS0peyBfcmVzdWx0cy5wdXNoKF9qKTsgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICAgIH0pLmFwcGx5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IF9rID0gMCwgX2xlbiA9IGZyYW1lcy5sZW5ndGg7IF9rIDwgX2xlbjsgaSA9ICsrX2spIHtcbiAgICAgICAgICBmcmFtZSA9IGZyYW1lc1tpXTtcbiAgICAgICAgICBmcmFtZXNbaV0gPSBNYXRoLmFicyhmcmFtZSAlIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBkaWdpdHMucHVzaChmcmFtZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldERpZ2l0cygpO1xuICAgICAgX3JlZiA9IGRpZ2l0cy5yZXZlcnNlKCk7XG4gICAgICBmb3IgKGkgPSBfbCA9IDAsIF9sZW4xID0gX3JlZi5sZW5ndGg7IF9sIDwgX2xlbjE7IGkgPSArK19sKSB7XG4gICAgICAgIGZyYW1lcyA9IF9yZWZbaV07XG4gICAgICAgIGlmICghdGhpcy5kaWdpdHNbaV0pIHtcbiAgICAgICAgICB0aGlzLmFkZERpZ2l0KCcgJywgaSA+PSBmcmFjdGlvbmFsQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2Jhc2UgPSB0aGlzLnJpYmJvbnMpW2ldID09IG51bGwpIHtcbiAgICAgICAgICBfYmFzZVtpXSA9IHRoaXMuZGlnaXRzW2ldLnF1ZXJ5U2VsZWN0b3IoJy5vZG9tZXRlci1yaWJib24taW5uZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJpYmJvbnNbaV0uaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgIGZyYW1lcyA9IGZyYW1lcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0gX20gPSAwLCBfbGVuMiA9IGZyYW1lcy5sZW5ndGg7IF9tIDwgX2xlbjI7IGogPSArK19tKSB7XG4gICAgICAgICAgZnJhbWUgPSBmcmFtZXNbal07XG4gICAgICAgICAgbnVtRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBudW1FbC5jbGFzc05hbWUgPSAnb2RvbWV0ZXItdmFsdWUnO1xuICAgICAgICAgIG51bUVsLmlubmVySFRNTCA9IGZyYW1lO1xuICAgICAgICAgIHRoaXMucmliYm9uc1tpXS5hcHBlbmRDaGlsZChudW1FbCk7XG4gICAgICAgICAgaWYgKGogPT09IGZyYW1lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhudW1FbCwgJ29kb21ldGVyLWxhc3QtdmFsdWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgIGFkZENsYXNzKG51bUVsLCAnb2RvbWV0ZXItZmlyc3QtdmFsdWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgdGhpcy5hZGREaWdpdCgnLScpO1xuICAgICAgfVxuICAgICAgbWFyayA9IHRoaXMuaW5zaWRlLnF1ZXJ5U2VsZWN0b3IoJy5vZG9tZXRlci1yYWRpeC1tYXJrJyk7XG4gICAgICBpZiAobWFyayAhPSBudWxsKSB7XG4gICAgICAgIG1hcmsucGFyZW50LnJlbW92ZUNoaWxkKG1hcmspO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWN0aW9uYWxDb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTcGFjZXIodGhpcy5mb3JtYXQucmFkaXgsIHRoaXMuZGlnaXRzW2ZyYWN0aW9uYWxDb3VudCAtIDFdLCAnb2RvbWV0ZXItcmFkaXgtbWFyaycpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gT2RvbWV0ZXI7XG5cbiAgfSkoKTtcblxuICBPZG9tZXRlci5vcHRpb25zID0gKF9yZWYgPSB3aW5kb3cub2RvbWV0ZXJPcHRpb25zKSAhPSBudWxsID8gX3JlZiA6IHt9O1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGssIHYsIF9iYXNlLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgaWYgKHdpbmRvdy5vZG9tZXRlck9wdGlvbnMpIHtcbiAgICAgIF9yZWYxID0gd2luZG93Lm9kb21ldGVyT3B0aW9ucztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKGsgaW4gX3JlZjEpIHtcbiAgICAgICAgdiA9IF9yZWYxW2tdO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKChfYmFzZSA9IE9kb21ldGVyLm9wdGlvbnMpW2tdICE9IG51bGwgPyAoX2Jhc2UgPSBPZG9tZXRlci5vcHRpb25zKVtrXSA6IF9iYXNlW2tdID0gdik7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfVxuICB9LCAwKTtcblxuICBPZG9tZXRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsLCBlbGVtZW50cywgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChPZG9tZXRlci5vcHRpb25zLnNlbGVjdG9yIHx8ICcub2RvbWV0ZXInKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZWxlbWVudHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGVsID0gZWxlbWVudHNbX2ldO1xuICAgICAgX3Jlc3VsdHMucHVzaChlbC5vZG9tZXRlciA9IG5ldyBPZG9tZXRlcih7XG4gICAgICAgIGVsOiBlbCxcbiAgICAgICAgdmFsdWU6IChfcmVmMSA9IGVsLmlubmVyVGV4dCkgIT0gbnVsbCA/IF9yZWYxIDogZWwudGV4dENvbnRlbnRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIGlmICgoKChfcmVmMSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgIT0gbnVsbCA/IF9yZWYxLmRvU2Nyb2xsIDogdm9pZCAwKSAhPSBudWxsKSAmJiAoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QgIT0gbnVsbCkpIHtcbiAgICBfb2xkID0gZG9jdW1lbnQub25yZWFkeXN0YXRlY2hhbmdlO1xuICAgIGRvY3VtZW50Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScgJiYgT2RvbWV0ZXIub3B0aW9ucy5hdXRvICE9PSBmYWxzZSkge1xuICAgICAgICBPZG9tZXRlci5pbml0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX29sZCAhPSBudWxsID8gX29sZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdm9pZCAwO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKE9kb21ldGVyLm9wdGlvbnMuYXV0byAhPT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIE9kb21ldGVyLmluaXQoKTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBPZG9tZXRlcjtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBleHBvcnRzICE9PSBudWxsKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBPZG9tZXRlcjtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuT2RvbWV0ZXIgPSBPZG9tZXRlcjtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/odometer/odometer.js\n"));

/***/ })

}]);